---
alwaysApply: true
---

# Tennis Computer Vision Analysis System - Cursor Rules

## Code Quality Standards

### Code Style
- Use descriptive variable names: `ball_trajectory` not `trajectory`, `player_position` not `pos`
- Use f-strings for string formatting: `f"Hello {name}"` not `"Hello {}".format(name)`
- Follow ruff formatting standards (configured in pyproject.toml)

### Type Hints
- Add type hints to all function parameters and return values
- Use `from typing import List, Dict, Optional, Tuple, Union` when needed
- Example: `def process_video_frames(frames: List[np.ndarray]) -> List[Dict[str, Any]]:`

### Error Handling
- Don't use bare `except:` - always specify exception types
- Log errors instead of using `print()` for debugging
- Return meaningful defaults (empty list, None) rather than crashing
- For video processing failures, return structured error info

### Imports
- Use explicit imports, avoid `from module import *`
- Import organization handled by ruff (configured in pyproject.toml)

### Code Quality Tools
- **Always run ruff before committing**: `ruff check .` and `ruff format .`
- **Fix auto-fixable issues**: `ruff check --fix .`
- **Format code**: `ruff format .`
- **Check specific file**: `ruff check backend/app/api/routes/video.py`
- **Format specific file**: `ruff format backend/app/api/routes/video.py`
- **Check new files/folders**: `ruff check backend/app/core/ backend/app/models/ backend/app/services/`
- **Format new files/folders**: `ruff format backend/app/core/ backend/app/models/ backend/app/services/`
- **When creating new Python files**: Always run ruff on the entire folder or new files
- **Common ruff issues to fix**:
  - `BLE001`: Don't use bare `except:` - specify exception types
  - `F841`: Remove unused variables
  - `E501`: Line too long (handled by ruff format)
  - `I001`: Import sorting (handled by ruff format)

### Solution Philosophy
- **Prefer simple solutions over complex ones** - When facing a problem, try the simplest approach first
- **Avoid hacky workarounds** - Don't use internal Python functions or complex conditional logic when clean alternatives exist
- **Self-correct when complexity creeps in** - If a solution feels overly complex, step back and look for a simpler approach
- **Module organization should be straightforward** - Avoid complex import gymnastics; prefer explicit imports and clean module structure

## Computer Vision Patterns

### Video Processing
- **Always use proper video handling with OpenCV**

  ```python
  # Good
  cap = cv2.VideoCapture(video_path)
  if not cap.isOpened():
      raise ValueError(f"Could not open video: {video_path}")
  
  # Process frames
  while cap.isOpened():
      ret, frame = cap.read()
      if not ret:
          break
      # Process frame
  cap.release()
  ```

- **Use efficient frame processing for large videos**

  ```python
  # Process every nth frame for performance
  frame_skip = max(1, int(fps / target_fps))
  frame_count = 0
  
  while cap.isOpened():
      ret, frame = cap.read()
      if not ret:
          break
      
      if frame_count % frame_skip == 0:
          # Process frame
          process_frame(frame)
      frame_count += 1
  ```

- **Handle video format variations robustly**

  ```python
  supported_formats = ['.mp4', '.avi', '.mov', '.mkv']
  if not any(video_path.lower().endswith(fmt) for fmt in supported_formats):
      raise ValueError(f"Unsupported video format: {video_path}")
  ```

### YOLO Integration
- **Use pre-trained models efficiently**

  ```python
  # Load model once, reuse for multiple videos
  model = YOLO('yolov8n.pt')  # Load once at startup
  
  def process_video(video_path: str) -> List[Dict]:
      results = model(video_path, stream=True)
      return [process_result(result) for result in results]
  ```

- **Handle model confidence thresholds**

  ```python
  # Use appropriate confidence thresholds
  BALL_CONFIDENCE_THRESHOLD = 0.5
  
  detections = [det for det in results if det.confidence > BALL_CONFIDENCE_THRESHOLD]
  ```

- **Implement proper error handling for model inference**

  ```python
  try:
      results = model(frame)
  except Exception as e:
      logger.error(f"Model inference failed: {e}")
      return []
  ```

## Database Operations

### SQLAlchemy Patterns
- **Use proper session management**

  ```python
  # Good - Proper session handling
  def save_analysis_results(video_id: str, results: List[Dict]) -> None:
      with Session() as session:
          for result in results:
              analysis = AnalysisResult(
                  video_id=video_id,
                  data=result
              )
              session.add(analysis)
          session.commit()
  ```

- **Handle database migrations properly**

  ```bash
  # Always run migrations after schema changes
  alembic revision --autogenerate -m "Add new table"
  alembic upgrade head
  ```

## FastAPI Patterns

### Request/Response Models
- **Use Pydantic models for validation**

  ```python
  class VideoUploadResponse(BaseModel):
      video_id: str
      filename: str
      status: str
      message: str
  ```

### Error Handling
- **Implement proper error responses**

  ```python
  @app.exception_handler(ValueError)
  async def value_error_handler(request: Request, exc: ValueError):
      return JSONResponse(
          status_code=400,
          content={"error": str(exc)}
      )
  ```

## Configuration Management

### Environment Variables
- **Use environment variables for configuration**

  ```python
  from dotenv import load_dotenv
  load_dotenv()

  DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./data/database/tennis_analysis.db")
  MAX_FILE_SIZE = int(os.getenv("MAX_FILE_SIZE", "104857600"))  # 100MB
  ```

### Virtual Environment
- **ALWAYS use the virtual environment**

  ```bash
  # ALWAYS activate venv first
  source venv/bin/activate

  # Then install packages
  pip install package_name

  # Then run code
  python script.py
  ```

## Function Design

### Keep Functions Focused
- One responsibility per function
- Use docstrings for any function longer than 5 lines
- If a function has more than 3 parameters, consider using a dataclass

### Docstrings and Comments
- **Docstrings:** All public classes and functions should have docstrings
- **Inline Comments:** Explain "why" not "what", focus on complex logic
- **Examples:**
  - Good: `# Skip frames with low confidence detections`
  - Good: `# Convert pixel coordinates to court positions`
  - Bad: `# set x to 5` (if the code is `x = 5`)

## Project Structure

### Module Organization
- `backend/app/api/` - FastAPI routes and endpoints
- `backend/app/core/` - Configuration and database setup
- `backend/app/services/` - Business logic (CV processing, analysis)
- `backend/app/utils/` - Shared utilities and helper functions
- `data/` - Video files and database
- `project_docs/` - Project documentation

### Naming Conventions
- Classes: `PascalCase` (VideoProcessor, AnalysisEngine)
- Functions/variables: `snake_case` (process_video, ball_trajectory)
- Constants: `UPPER_SNAKE_CASE` (MAX_FILE_SIZE, CONFIDENCE_THRESHOLD)
- Files: `snake_case.py` (video_processor.py, cv_pipeline.py)

## Tennis-Specific Patterns

### Court Position Analysis
- **Use consistent coordinate systems**

  ```python
  # Define court boundaries
  COURT_WIDTH = 10.97  # meters
  COURT_LENGTH = 23.77  # meters
  
  def normalize_court_position(x: float, y: float) -> Tuple[float, float]:
      """Convert pixel coordinates to normalized court positions (0-1)"""
      return x / COURT_WIDTH, y / COURT_LENGTH
  ```

### Ball Tracking
- **Implement robust ball tracking**

  ```python
  def track_ball(detections: List[Dict]) -> List[Tuple[float, float]]:
      """Track ball across frames with Kalman filtering"""
      # Use tracking algorithms for smooth trajectories
      pass
  ```

## Git Workflow & Version Control

### Branch Strategy
- **Main branch**: `main` - Always stable, deployable code
- **Feature branches**: `feature/description` - For new features
- **Bug fix branches**: `fix/description` - For bug fixes
- **Hotfix branches**: `hotfix/description` - For urgent fixes

### Branch Naming Conventions
- Use descriptive branch names: `feature/video-upload`, `fix/ball-tracking-error`
- Use kebab-case for branch names
- Include ticket/issue number if applicable: `feature/TENNIS-123-video-processing`

### Commit Guidelines
- **Use conventional commits**: `feat:`, `fix:`, `docs:`, `style:`, `refactor:`, `test:`, `chore:`
- **Write descriptive commit messages**: Explain what and why, not how
- **Keep commits atomic**: One logical change per commit
- **Examples:**
  - `feat: add video upload endpoint with file validation`
  - `fix: resolve ball tracking accuracy in low-light conditions`
  - `docs: update API documentation for new endpoints`

### Git Workflow Commands
```bash
# Start new feature
git checkout main
git pull origin main
git checkout -b feature/video-processing

# Make changes and commit
git add .
git commit -m "feat: implement video processing pipeline"

# Push and create PR
git push origin feature/video-processing
```

### Pull Request Guidelines
- **Create PRs for all changes** (except documentation)
- **Use descriptive PR titles**: "Add video upload functionality"
- **Include detailed descriptions**: What was changed, why, how to test
- **Link related issues**: "Fixes #123" or "Closes #456"
- **Request reviews**: Get feedback before merging

### Code Review Process
- **Review your own code first** - Self-review before requesting review
- **Address all review comments** - Don't merge with unresolved comments
- **Keep PRs small and focused** - Easier to review and understand
- **Test thoroughly** - Ensure code works before requesting review

### Merge Strategy
- **Squash and merge** - Keep main branch history clean
- **Delete feature branches** - After successful merge
- **Update main branch** - Always pull latest before creating new branches

### Git Best Practices
- **Never commit directly to main** - Always use feature branches
- **Keep commits small and focused** - One logical change per commit
- **Write meaningful commit messages** - Future you will thank you
- **Use .gitignore properly** - Don't commit temporary files
- **Regular pulls** - Keep your local main up to date

## Development Workflow

### Phase-Based Development
- Complete each task before moving to the next
- Document any deviations from planned approach
- **Create feature branch for each phase** - Keep work organized

### Testing Strategy
- Write tests for video processing logic
- Mock external APIs and CV models for unit testing
- Use test videos for integration testing
- Test database operations with test data

### Code Review Guidelines
- **Review for simplicity** - Is this the simplest solution?
- **Check error handling** - Are all edge cases handled?
- **Verify type hints** - Are all functions properly typed?
- **Test documentation** - Are new features documented?

## Portfolio Guidelines

### Code Quality for Portfolio
- **Write clean, well-documented code** - This will be reviewed
- **Follow best practices** - Demonstrate professional development skills
- **Include comprehensive tests** - Show testing knowledge
- **Document architecture decisions** - Explain technical choices

### Project Presentation
- **Keep README updated** - Clear project status and features
- **Document technical challenges** - Explain how you solved problems